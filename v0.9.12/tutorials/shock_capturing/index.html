<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>5 Shock capturing with flux differencing and stage limiter · Trixi.jl</title><meta name="title" content="5 Shock capturing with flux differencing and stage limiter · Trixi.jl"/><meta property="og:title" content="5 Shock capturing with flux differencing and stage limiter · Trixi.jl"/><meta property="twitter:title" content="5 Shock capturing with flux differencing and stage limiter · Trixi.jl"/><meta name="description" content="Documentation for Trixi.jl."/><meta property="og:description" content="Documentation for Trixi.jl."/><meta property="twitter:description" content="Documentation for Trixi.jl."/><meta property="og:url" content="https://trixi-framework.github.io/Trixi.jl/stable/tutorials/shock_capturing/"/><meta property="twitter:url" content="https://trixi-framework.github.io/Trixi.jl/stable/tutorials/shock_capturing/"/><link rel="canonical" href="https://trixi-framework.github.io/Trixi.jl/stable/tutorials/shock_capturing/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Trixi.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../../overview/">Overview</a></li><li><a class="tocitem" href="../../visualization/">Visualization</a></li><li><a class="tocitem" href="../../restart/">Restart simulation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">1 First steps in Trixi.jl</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../first_steps/getting_started/">1.1 Getting started</a></li><li><a class="tocitem" href="../first_steps/create_first_setup/">1.2 Create your first setup</a></li><li><a class="tocitem" href="../first_steps/changing_trixi/">1.3 Changing Trixi.jl itself</a></li></ul></li><li><a class="tocitem" href="../behind_the_scenes_simulation_setup/">2 Behind the scenes of a simulation setup</a></li><li><a class="tocitem" href="../scalar_linear_advection_1d/">3 Introduction to DG methods</a></li><li><a class="tocitem" href="../DGSEM_FluxDiff/">4 DGSEM with flux differencing</a></li><li class="is-active"><a class="tocitem" href>5 Shock capturing with flux differencing and stage limiter</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Shock-capturing-with-flux-differencing"><span>Shock capturing with flux differencing</span></a></li><li class="toplevel"><a class="tocitem" href="#Positivity-preserving-limiter"><span>Positivity preserving limiter</span></a></li><li class="toplevel"><a class="tocitem" href="#Simulation-with-shock-capturing-and-positivity-preserving"><span>Simulation with shock capturing and positivity preserving</span></a></li><li class="toplevel"><a class="tocitem" href="#Entropy-bounded-limiter"><span>Entropy bounded limiter</span></a></li><li><a class="tocitem" href="#Package-versions"><span>Package versions</span></a></li></ul></li><li><a class="tocitem" href="../subcell_shock_capturing/">6 Subcell limiting with the IDP Limiter</a></li><li><a class="tocitem" href="../non_periodic_boundaries/">7 Non-periodic boundaries</a></li><li><a class="tocitem" href="../DGMulti_1/">8 DG schemes via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="../DGMulti_2/">9 Other SBP schemes (FD, CGSEM) via <code>DGMulti</code> solver</a></li><li><a class="tocitem" href="../upwind_fdsbp/">10 Upwind FD SBP schemes</a></li><li><a class="tocitem" href="../adding_new_scalar_equations/">11 Adding a new scalar conservation law</a></li><li><a class="tocitem" href="../adding_nonconservative_equation/">12 Adding a non-conservative equation</a></li><li><a class="tocitem" href="../parabolic_terms/">13 Parabolic terms</a></li><li><a class="tocitem" href="../adding_new_parabolic_terms/">14 Adding new parabolic terms</a></li><li><a class="tocitem" href="../adaptive_mesh_refinement/">15 Adaptive mesh refinement</a></li><li><a class="tocitem" href="../structured_mesh_mapping/">16 Structured mesh with curvilinear mapping</a></li><li><a class="tocitem" href="../hohqmesh_tutorial/">17 Unstructured meshes with HOHQMesh.jl</a></li><li><a class="tocitem" href="../p4est_from_gmsh/">18 P4est mesh from gmsh</a></li><li><a class="tocitem" href="../time_stepping/">19 Explicit time stepping</a></li><li><a class="tocitem" href="../differentiable_programming/">20 Differentiable programming</a></li><li><a class="tocitem" href="../custom_semidiscretization/">21 Custom semidiscretizations</a></li></ul></li><li><span class="tocitem">Basic building blocks</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Meshes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../meshes/tree_mesh/">Tree mesh</a></li><li><a class="tocitem" href="../../meshes/structured_mesh/">Structured mesh</a></li><li><a class="tocitem" href="../../meshes/unstructured_quad_mesh/">Unstructured mesh</a></li><li><a class="tocitem" href="../../meshes/p4est_mesh/">P4est-based mesh</a></li><li><a class="tocitem" href="../../meshes/dgmulti_mesh/">DGMulti mesh</a></li></ul></li><li><a class="tocitem" href="../../time_integration/">Time integration</a></li><li><a class="tocitem" href="../../callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../multi-physics_coupling/">Coupling</a></li></ul></li><li><span class="tocitem">Advanced topics &amp; developers</span><ul><li><a class="tocitem" href="../../conventions/">Conventions</a></li><li><a class="tocitem" href="../../development/">Development</a></li><li><a class="tocitem" href="../../github-git/">GitHub &amp; Git</a></li><li><a class="tocitem" href="../../styleguide/">Style guide</a></li><li><a class="tocitem" href="../../testing/">Testing</a></li><li><a class="tocitem" href="../../performance/">Performance</a></li><li><a class="tocitem" href="../../parallelization/">Parallelization</a></li></ul></li><li><a class="tocitem" href="../../troubleshooting/">Troubleshooting and FAQ</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference-trixi/">Trixi.jl</a></li><li><a class="tocitem" href="../../reference-trixibase/">TrixiBase.jl</a></li><li><a class="tocitem" href="../../reference-trixi2vtk/">Trixi2Vtk.jl</a></li></ul></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li><li><a class="tocitem" href="../../authors/">Authors</a></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../code_of_conduct/">Code of Conduct</a></li><li><a class="tocitem" href="../../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>5 Shock capturing with flux differencing and stage limiter</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>5 Shock capturing with flux differencing and stage limiter</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/trixi-framework/Trixi.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/trixi-framework/Trixi.jl/blob/main/docs/literate/src/files/shock_capturing.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="shock_capturing"><a class="docs-heading-anchor" href="#shock_capturing">5: Shock capturing with flux differencing and stage limiter</a><a id="shock_capturing-1"></a><a class="docs-heading-anchor-permalink" href="#shock_capturing" title="Permalink"></a></h1><p><a href="https://mybinder.org/v2/gh/trixi-framework/Trixi.jl/tutorial_notebooks?filepath=tutorials/notebooks/shock_capturing.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a> <a href="https://nbviewer.jupyter.org/github/trixi-framework/Trixi.jl/blob/tutorial_notebooks/tutorials/notebooks/shock_capturing.ipynb"><img src="https://img.shields.io/badge/render-nbviewer-f37726" alt/></a> <a href="https://raw.githubusercontent.com/trixi-framework/Trixi.jl/tutorial_notebooks/tutorials/notebooks/shock_capturing.ipynb"><img src="https://img.shields.io/badge/raw-notebook-4cc61e" alt/></a></p><p>This tutorial contains a short summary of the idea of shock capturing for DGSEM with flux differencing and its implementation in <a href="https://github.com/trixi-framework/Trixi.jl">Trixi.jl</a>. In the second part, an implementation of a positivity preserving limiter is added to the simulation.</p><h1 id="Shock-capturing-with-flux-differencing"><a class="docs-heading-anchor" href="#Shock-capturing-with-flux-differencing">Shock capturing with flux differencing</a><a id="Shock-capturing-with-flux-differencing-1"></a><a class="docs-heading-anchor-permalink" href="#Shock-capturing-with-flux-differencing" title="Permalink"></a></h1><p>The following rough explanation is on a very basic level. More information about an entropy stable shock-capturing strategy for DGSEM discretizations of advection dominated problems, such as the compressible Euler equations or the compressible Navier-Stokes equations, can be found in <a href="https://doi.org/10.1016/j.jcp.2020.109935">Hennemann et al. (2021)</a>. In <a href="https://doi.org/10.1016/j.jcp.2021.110580">Rueda-Ramírez et al. (2021)</a> you find the extension to the systems with non-conservative terms, such as the compressible magnetohydrodynamics (MHD) equations.</p><p>The strategy for a shock-capturing method presented by Hennemann et al. is based on a hybrid blending of a high-order DG method with a low-order variant. The low-order subcell finite volume (FV) method is created directly with the Legendre-Gauss-Lobatto (LGL) nodes already used for the high-order DGSEM. Then, the final method is a convex combination with regulating indicator <span>$\alpha$</span> of these two methods.</p><p>Since the surface integral is equal for both the DG and the subcell FV method, only the volume integral divides between the two methods.</p><p>This strategy for the volume integral is implemented in Trixi.jl under the name of <a href="../../reference-trixi/#Trixi.VolumeIntegralShockCapturingHG"><code>VolumeIntegralShockCapturingHG</code></a> with the three parameters of the indicator and the volume fluxes for the DG and the subcell FV method.</p><p>Note, that the DG method is based on the flux differencing formulation. Hence, you have to use a two-point flux, such as <a href="../../reference-trixi/#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a>, <a href="../../reference-trixi/#Trixi.flux_shima_etal-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_shima_etal</code></a>, <a href="../../reference-trixi/#Trixi.flux_chandrashekar-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_chandrashekar</code></a> or <a href="../../reference-trixi/#Trixi.flux_kennedy_gruber-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_kennedy_gruber</code></a>, for the DG volume flux. We would recommend to use the entropy conserving flux <code>flux_ranocha</code> by <a href="https://cuvillier.de/en/shop/publications/7743">Ranocha (2018)</a> for the compressible Euler equations.</p><pre><code class="language-julia hljs">volume_integral = VolumeIntegralShockCapturingHG(indicator_sc;
                                                 volume_flux_dg=volume_flux_dg,
                                                 volume_flux_fv=volume_flux_fv)</code></pre><p>We now focus on a choice of the shock capturing indicator <code>indicator_sc</code>. A possible indicator is <span>$\alpha_{HG}$</span> presented by Hennemann et al. (p.10), which depends on the current approximation with modal coefficients <span>$\{m_j\}_{j=0}^N$</span> of a given <code>variable</code>.</p><p>The indicator is calculated for every DG element by itself. First, we calculate a smooth <span>$\alpha$</span> by</p><p class="math-container">\[\alpha = \frac{1}{1+\exp(-\frac{-s}{\mathbb{T}}(\mathbb{E}-\mathbb{T}))}\]</p><p>with the total energy <span>$\mathbb{E}=\max\big(\frac{m_N^2}{\sum_{j=0}^N m_j^2}, \frac{m_{N-1}^2}{\sum_{j=0}^{N-1} m_j^2}\big)$</span>, threshold <span>$\mathbb{T}= 0.5 * 10^{-1.8*(N+1)^{1/4}}$</span> and parameter <span>$s=ln\big(\frac{1-0.0001}{0.0001}\big)\approx 9.21024$</span>.</p><p>For computational efficiency, <span>$\alpha_{min}$</span> is introduced and used for</p><p class="math-container">\[\tilde{\alpha} = \begin{cases}
0, &amp; \text{if } \alpha&lt;\alpha_{min}\\
\alpha, &amp; \text{if } \alpha_{min}\leq \alpha \leq 1- \alpha_{min}\\
1, &amp; \text{if } 1-\alpha_{min}&lt;\alpha.
\end{cases}\]</p><p>Moreover, the parameter <span>$\alpha_{max}$</span> sets a maximal value for <span>$\alpha$</span> by</p><p class="math-container">\[\alpha = \min\{\tilde{\alpha}, \alpha_{max}\}.\]</p><p>This allows to control the maximal dissipation.</p><p>To remove numerical artifact the final indicator is smoothed with all the neighboring elements&#39; indicators. This is activated with <code>alpha_smooth=true</code>.</p><p class="math-container">\[\alpha_{HG} = \max_E \{ \alpha, 0.5 * \alpha_E\},\]</p><p>where <span>$E$</span> are all elements sharing a face with the current element.</p><p>Furthermore, you can specify the variable used for the calculation. For instance you can choose <code>density</code>, <code>pressure</code> or both with <code>density_pressure</code> for the compressible Euler equations. For every equation there is also the option to use the first conservation variable with <code>first</code>.</p><p>This indicator is implemented in Trixi.jl and called <a href="../../reference-trixi/#Trixi.IndicatorHennemannGassner"><code>IndicatorHennemannGassner</code></a> with the parameters <code>equations</code>, <code>basis</code>, <code>alpha_max</code>, <code>alpha_min</code>, <code>alpha_smooth</code> and <code>variable</code>.</p><pre><code class="language-julia hljs">indicator_sc = IndicatorHennemannGassner(equations, basis,
                                         alpha_max=0.5,
                                         alpha_min=0.001,
                                         alpha_smooth=true,
                                         variable=variable)</code></pre><h1 id="Positivity-preserving-limiter"><a class="docs-heading-anchor" href="#Positivity-preserving-limiter">Positivity preserving limiter</a><a id="Positivity-preserving-limiter-1"></a><a class="docs-heading-anchor-permalink" href="#Positivity-preserving-limiter" title="Permalink"></a></h1><p>Some numerical solutions are physically meaningless, for instance negative values of pressure or density for the compressible Euler equations. This often results in crashed simulations since the calculation of numerical fluxes or stable time steps uses mathematical operations like roots or logarithms. One option to avoid these cases are a-posteriori positivity preserving limiters. Trixi.jl provides the fully-discrete positivity-preserving limiter of <a href="https://doi.org/10.1098/rspa.2011.0153">Zhang, Shu (2011)</a>.</p><p>It works the following way. For every passed (scalar) variable and for every DG element we calculate the minimal value <span>$value_\text{min}$</span>. If this value falls below the given threshold <span>$\varepsilon$</span>, the approximation is slightly adapted such that the minimal value of the relevant variable lies now above the threshold.</p><p class="math-container">\[\underline{u}^\text{new} = \theta * \underline{u} + (1-\theta) * u_\text{mean}\]</p><p>where <span>$\underline{u}$</span> are the collected pointwise evaluation coefficients in element <span>$e$</span> and <span>$u_\text{mean}$</span> the integral mean of the quantity in <span>$e$</span>. The new coefficients are a convex combination of these two values with factor</p><p class="math-container">\[\theta = \frac{value_\text{mean} - \varepsilon}{value_\text{mean} - value_\text{min}},\]</p><p>where <span>$value_\text{mean}$</span> is the relevant variable evaluated for the mean value <span>$u_\text{mean}$</span>.</p><p>The adapted approximation keeps the exact same mean value, but the relevant variable is now greater or equal the threshold <span>$\varepsilon$</span> at every node in every element.</p><p>We specify the variables the way we did before for the shock capturing variables. For the compressible Euler equations <code>density</code>, <code>pressure</code> or the combined variable <code>density_pressure</code> are a reasonable choice.</p><p>You can implement the limiter in Trixi.jl using <a href="../../reference-trixi/#Trixi.PositivityPreservingLimiterZhangShu"><code>PositivityPreservingLimiterZhangShu</code></a> with parameters <code>threshold</code> and <code>variables</code>.</p><pre><code class="language-julia hljs">stage_limiter! = PositivityPreservingLimiterZhangShu(thresholds=thresholds,
                                                     variables=variables)</code></pre><p>Then, the limiter is added to the time integration method in the <code>solve</code> function. For instance, like</p><pre><code class="language-julia hljs">CarpenterKennedy2N54(stage_limiter!, williamson_condition=false)</code></pre><p>or</p><pre><code class="language-julia hljs">SSPRK43(stage_limiter!).</code></pre><h1 id="Simulation-with-shock-capturing-and-positivity-preserving"><a class="docs-heading-anchor" href="#Simulation-with-shock-capturing-and-positivity-preserving">Simulation with shock capturing and positivity preserving</a><a id="Simulation-with-shock-capturing-and-positivity-preserving-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-with-shock-capturing-and-positivity-preserving" title="Permalink"></a></h1><p>Now, we can run a simulation using the described methods of shock capturing and positivity preserving limiters. We want to give an example for the 2D compressible Euler equations.</p><pre><code class="language-julia hljs">using OrdinaryDiffEq, Trixi

equations = CompressibleEulerEquations2D(1.4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ CompressibleEulerEquations2D                                                                     │
│ ════════════════════════════                                                                     │
│ #variables: ………………………………………………… 4                                                                │
│ │ variable 1: …………………………………………… rho                                                              │
│ │ variable 2: …………………………………………… rho_v1                                                           │
│ │ variable 3: …………………………………………… rho_v2                                                           │
│ │ variable 4: …………………………………………… rho_e                                                            │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>As our initial condition we use the Sedov blast wave setup.</p><pre><code class="language-julia hljs">function initial_condition_sedov_blast_wave(x, t, equations::CompressibleEulerEquations2D)
    # Set up polar coordinates
    inicenter = SVector(0.0, 0.0)
    x_norm = x[1] - inicenter[1]
    y_norm = x[2] - inicenter[2]
    r = sqrt(x_norm^2 + y_norm^2)

    r0 = 0.21875 # = 3.5 * smallest dx (for domain length=4 and max-ref=6)
    # r0 = 0.5 # = more reasonable setup
    E = 1.0
    p0_inner = 3 * (equations.gamma - 1) * E / (3 * pi * r0^2)
    p0_outer = 1.0e-5 # = true Sedov setup
    # p0_outer = 1.0e-3 # = more reasonable setup

    # Calculate primitive variables
    rho = 1.0
    v1 = 0.0
    v2 = 0.0
    p = r &gt; r0 ? p0_outer : p0_inner

    return prim2cons(SVector(rho, v1, v2, p), equations)
end
initial_condition = initial_condition_sedov_blast_wave</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">initial_condition_sedov_blast_wave (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">basis = LobattoLegendreBasis(3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LobattoLegendreBasis{Float64} with polynomials of degree 3</code></pre><p>We set the numerical fluxes and divide between the surface flux and the two volume fluxes for the DG and FV method. Here, we are using <a href="../../reference-trixi/#Trixi.flux_lax_friedrichs"><code>flux_lax_friedrichs</code></a> and <a href="../../reference-trixi/#Trixi.flux_ranocha-Tuple{Any, Any, Integer, CompressibleEulerEquations1D}"><code>flux_ranocha</code></a>.</p><pre><code class="language-julia hljs">surface_flux = flux_lax_friedrichs
volume_flux = flux_ranocha</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">flux_ranocha (generic function with 9 methods)</code></pre><p>Now, we specify the shock capturing indicator <span>$\alpha$</span>.</p><p>We implement the described indicator of Hennemann, Gassner as explained above with parameters <code>equations</code>, <code>basis</code>, <code>alpha_max</code>, <code>alpha_min</code>, <code>alpha_smooth</code> and <code>variable</code>. Since density and pressure are the critical variables in this example, we use <code>density_pressure = density * pressure = rho * p</code> as indicator variable.</p><pre><code class="language-julia hljs">indicator_sc = IndicatorHennemannGassner(equations, basis,
                                         alpha_max = 0.5,
                                         alpha_min = 0.001,
                                         alpha_smooth = true,
                                         variable = density_pressure)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ IndicatorHennemannGassner                                                                        │
│ ═════════════════════════                                                                        │
│ indicator variable: …………………………… density_pressure                                                 │
│ max. α: …………………………………………………………… 0.5                                                              │
│ min. α: …………………………………………………………… 0.001                                                            │
│ smooth α: ……………………………………………………… yes                                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>Now, we can use the defined fluxes and the indicator to implement the volume integral using shock capturing.</p><pre><code class="language-julia hljs">volume_integral = VolumeIntegralShockCapturingHG(indicator_sc;
                                                 volume_flux_dg = volume_flux,
                                                 volume_flux_fv = surface_flux)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ VolumeIntegralShockCapturingHG                                                                   │
│ ══════════════════════════════                                                                   │
│ volume flux DG: ……………………………………… flux_ranocha                                                     │
│ volume flux FV: ……………………………………… FluxLaxFriedrichs(max_abs_speed_naive)                           │
│ indicator: …………………………………………………… IndicatorHennemannGassner                                        │
│ │ indicator variable: ……………………… density_pressure                                                 │
│ │ max. α: ……………………………………………………… 0.5                                                              │
│ │ min. α: ……………………………………………………… 0.001                                                            │
│ │ smooth α: ………………………………………………… yes                                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>We finalize the discretization by implementing Trixi.jl&#39;s <code>solver</code>, <code>mesh</code>, <code>semi</code> and <code>ode</code>, while <code>solver</code> now has the extra parameter <code>volume_integral</code>.</p><pre><code class="language-julia hljs">solver = DGSEM(basis, surface_flux, volume_integral)

coordinates_min = (-2.0, -2.0)
coordinates_max = (2.0, 2.0)
mesh = TreeMesh(coordinates_min, coordinates_max,
                initial_refinement_level = 6,
                n_cells_max = 10_000)

semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver)

tspan = (0.0, 1.0)
ode = semidiscretize(semi, tspan);</code></pre><p>We add some callbacks to get an solution analysis and use a CFL-based time step size calculation.</p><pre><code class="language-julia hljs">analysis_callback = AnalysisCallback(semi, interval = 100)

stepsize_callback = StepsizeCallback(cfl = 0.8)

callbacks = CallbackSet(analysis_callback, stepsize_callback);</code></pre><p>We now run the simulation using the positivity preserving limiter of Zhang and Shu for the variables density and pressure.</p><pre><code class="language-julia hljs">stage_limiter! = PositivityPreservingLimiterZhangShu(thresholds = (5.0e-6, 5.0e-6),
                                                     variables = (Trixi.density, pressure))

sol = solve(ode, CarpenterKennedy2N54(stage_limiter!, williamson_condition = false),
            dt = 1.0, # solve needs some value here but it will be overwritten by the stepsize_callback
            save_everystep = false, callback = callbacks);

using Plots
plot(sol)</code></pre><img src="0d08d5c2.svg" alt="Example block output"/><h1 id="Entropy-bounded-limiter"><a class="docs-heading-anchor" href="#Entropy-bounded-limiter">Entropy bounded limiter</a><a id="Entropy-bounded-limiter-1"></a><a class="docs-heading-anchor-permalink" href="#Entropy-bounded-limiter" title="Permalink"></a></h1><p>As argued in the description of the positivity preserving limiter above it might sometimes be necessary to apply advanced techniques to ensure a physically meaningful solution. Apart from the positivity of pressure and density, the physical entropy of the system should increase over the course of a simulation, see e.g. <a href="https://doi.org/10.1016/0168-9274(86)90029-2">this</a> paper by Tadmor where this property is shown for the compressible Euler equations. As this is not necessarily the case for the numerical approximation (especially for the high-order, non-diffusive DG discretizations), Lv and Ihme devised an a-posteriori limiter in <a href="https://doi.org/10.1016/j.jcp.2015.04.026">this paper</a> which can be applied after each Runge-Kutta stage. This limiter enforces a non-decrease in the physical, thermodynamic entropy <span>$S$</span> by bounding the entropy decrease (entropy increase is always tolerated) <span>$\Delta S$</span> in each grid cell.</p><p>This translates into a requirement that the entropy of the limited approximation <span>$S\Big(\mathcal{L}\big[\boldsymbol u(\Delta t) \big] \Big)$</span> should be greater or equal than the previous iterates&#39; entropy <span>$S\big(\boldsymbol u(0) \big)$</span>, enforced at each quadrature point:</p><p class="math-container">\[S\Big(\mathcal{L}\big[\boldsymbol u(\Delta t, \boldsymbol{x}_i) \big] \Big) \overset{!}{\geq} S\big(\boldsymbol u(0, \boldsymbol{x}_i) \big), \quad i = 1, \dots, (k+1)^d\]</p><p>where <span>$k$</span> denotes the polynomial degree of the element-wise solution and <span>$d$</span> is the spatial dimension. For an ideal gas, the thermodynamic entropy <span>$S(\boldsymbol u) = S(p, \rho)$</span> is given by</p><p class="math-container">\[S(p, \rho) = \ln \left( \frac{p}{\rho^\gamma} \right) \: .\]</p><p>Thus, the non-decrease in entropy can be reformulated as</p><p class="math-container">\[p(\boldsymbol{x}_i) - e^{ S\big(\boldsymbol u(0, \boldsymbol{x}_i) \big)} \cdot \rho(\boldsymbol{x}_i)^\gamma \overset{!}{\geq} 0, \quad i = 1, \dots, (k+1)^d \: .\]</p><p>In a practical simulation, we might tolerate a maximum (exponentiated) entropy decrease per element, i.e.,</p><p class="math-container">\[\Delta e^S \coloneqq \min_{i} \left\{ p(\boldsymbol{x}_i) - e^{ S\big(\boldsymbol u(0, \boldsymbol{x}_i) \big)} \cdot \rho(\boldsymbol{x}_i)^\gamma \right\} &lt; c\]</p><p>with hyper-parameter <span>$c$</span> which is to be specified by the user. The default value for the corresponding parameter <span>$c=$</span> <code>exp_entropy_decrease_max</code> is set to <span>$-10^{-13}$</span>, i.e., slightly less than zero to avoid spurious limiter actions for cells in which the entropy remains effectively constant. Other values can be specified by setting the <code>exp_entropy_decrease_max</code> keyword in the constructor of the limiter:</p><pre><code class="language-julia hljs">stage_limiter! = EntropyBoundedLimiter(exp_entropy_decrease_max=-1e-9)</code></pre><p>Smaller values (larger in absolute value) for <code>exp_entropy_decrease_max</code> relax the entropy increase requirement and are thus less diffusive. On the other hand, for larger values (smaller in absolute value) of <code>exp_entropy_decrease_max</code> the limiter acts more often and the solution becomes more diffusive.</p><p>In particular, we compute again a limiting parameter <span>$\vartheta \in [0, 1]$</span> which is then used to blend the unlimited nodal values <span>$\boldsymbol u$</span> with the mean value <span>$\boldsymbol u_{\text{mean}}$</span> of the element:</p><p class="math-container">\[\mathcal{L} [\boldsymbol u](\vartheta) \coloneqq (1 - \vartheta) \boldsymbol u + \vartheta \cdot \boldsymbol u_{\text{mean}}\]</p><p>For the exact definition of <span>$\vartheta$</span> the interested user is referred to section 4.4 of the paper by Lv and Ihme. Note that therein the limiting parameter is denoted by <span>$\epsilon$</span>, which is not to be confused with the threshold <span>$\varepsilon$</span> of the Zhang-Shu limiter.</p><p>As for the positivity preserving limiter, the entropy bounded limiter may be applied after every Runge-Kutta stage. Both fixed timestep methods such as <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/"><code>CarpenterKennedy2N54</code></a> and adaptive timestep methods such as <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/"><code>SSPRK43</code></a> are supported. We would like to remark that of course every <code>stage_limiter!</code> can also be used as a <code>step_limiter!</code>, i.e., acting only after the full time step has been taken.</p><p>As an example, we consider a variant of the <a href="https://github.com/trixi-framework/Trixi.jl/blob/main/examples/tree_1d_dgsem/elixir_euler_blast_wave.jl">1D medium blast wave example</a> wherein the shock capturing method discussed above is employed to handle the shock. Here, we use a standard DG solver with HLLC surface flux:</p><pre><code class="language-julia hljs">using Trixi

solver = DGSEM(polydeg = 3, surface_flux = flux_hllc)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ DG{Float64}                                                                                      │
│ ═══════════                                                                                      │
│ basis: ……………………………………………………………… LobattoLegendreBasis{Float64}(polydeg=3)                         │
│ mortar: …………………………………………………………… LobattoLegendreMortarL2{Float64}(polydeg=3)                      │
│ surface integral: ………………………………… SurfaceIntegralWeakForm                                          │
│ │ surface flux: ……………………………………… flux_hllc                                                        │
│ volume integral: …………………………………… VolumeIntegralWeakForm                                           │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>The remaining setup is the same as in the standard example:</p><pre><code class="language-julia hljs">using OrdinaryDiffEq

###############################################################################</code></pre><p>semidiscretization of the compressible Euler equations</p><pre><code class="language-julia hljs">equations = CompressibleEulerEquations1D(1.4)

function initial_condition_blast_wave(x, t, equations::CompressibleEulerEquations1D)
    # Modified From Hennemann &amp; Gassner JCP paper 2020 (Sec. 6.3) -&gt; &quot;medium blast wave&quot;
    # Set up polar coordinates
    inicenter = SVector(0.0)
    x_norm = x[1] - inicenter[1]
    r = abs(x_norm)
    # The following code is equivalent to
    # phi = atan(0.0, x_norm)
    # cos_phi = cos(phi)
    # in 1D but faster
    cos_phi = x_norm &gt; 0 ? one(x_norm) : -one(x_norm)

    # Calculate primitive variables
    rho = r &gt; 0.5 ? 1.0 : 1.1691
    v1 = r &gt; 0.5 ? 0.0 : 0.1882 * cos_phi
    p = r &gt; 0.5 ? 1.0E-3 : 1.245

    return prim2cons(SVector(rho, v1, p), equations)
end
initial_condition = initial_condition_blast_wave

coordinates_min = (-2.0,)
coordinates_max = (2.0,)
mesh = TreeMesh(coordinates_min, coordinates_max,
                initial_refinement_level = 6,
                n_cells_max = 10_000)

semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver)

###############################################################################</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌──────────────────────────────────────────────────────────────────────────────────────────────────┐
│ SemidiscretizationHyperbolic                                                                     │
│ ════════════════════════════                                                                     │
│ #spatial dimensions: ………………………… 1                                                                │
│ mesh: ………………………………………………………………… TreeMesh{1, Trixi.SerialTree{1, Float64}} with length 127        │
│ equations: …………………………………………………… CompressibleEulerEquations1D                                     │
│ initial condition: ……………………………… initial_condition_blast_wave                                     │
│ boundary conditions: ………………………… Trixi.BoundaryConditionPeriodic                                  │
│ source terms: …………………………………………… nothing                                                          │
│ solver: …………………………………………………………… DG                                                               │
│ total #DOFs per field: …………………… 256                                                              │
└──────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre><p>ODE solvers, callbacks etc.</p><pre><code class="language-julia hljs">tspan = (0.0, 12.5)
ode = semidiscretize(semi, tspan)

summary_callback = SummaryCallback()

analysis_interval = 100

analysis_callback = AnalysisCallback(semi, interval = analysis_interval)

alive_callback = AliveCallback(analysis_interval = analysis_interval)

stepsize_callback = StepsizeCallback(cfl = 0.5)

callbacks = CallbackSet(summary_callback,
                        analysis_callback, alive_callback,
                        stepsize_callback)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CallbackSet{Tuple{}, Tuple{DiscreteCallback{typeof(Trixi.summary_callback), typeof(Trixi.summary_callback), Trixi.var&quot;#initialize#1423&quot;{Bool}, typeof(SciMLBase.FINALIZE_DEFAULT)}, DiscreteCallback{Trixi.var&quot;#1429#1436&quot;{Int64}, AnalysisCallback{Trixi.LobattoLegendreAnalyzer{Float64, 7, SVector{7, Float64}, Matrix{Float64}}, Tuple{typeof(Trixi.entropy_timederivative)}, SVector{3, Float64}, @NamedTuple{u_local::StrideArraysCore.StaticStrideArray{Float64, 2, (1, 2), Tuple{Static.StaticInt{3}, Static.StaticInt{7}}, Tuple{Nothing, Nothing}, Tuple{Static.StaticInt{1}, Static.StaticInt{1}}, 21}, x_local::StrideArraysCore.StaticStrideArray{Float64, 2, (1, 2), Tuple{Static.StaticInt{1}, Static.StaticInt{7}}, Tuple{Nothing, Nothing}, Tuple{Static.StaticInt{1}, Static.StaticInt{1}}, 7}}}, typeof(Trixi.initialize!), typeof(SciMLBase.FINALIZE_DEFAULT)}, DiscreteCallback{AliveCallback, AliveCallback, typeof(Trixi.initialize!), typeof(SciMLBase.FINALIZE_DEFAULT)}, DiscreteCallback{StepsizeCallback{Float64}, StepsizeCallback{Float64}, typeof(Trixi.initialize!), typeof(SciMLBase.FINALIZE_DEFAULT)}}}((), (SummaryCallback, DiscreteCallback{Trixi.var&quot;#1429#1436&quot;{Int64}, AnalysisCallback{Trixi.LobattoLegendreAnalyzer{Float64, 7, SVector{7, Float64}, Matrix{Float64}}, Tuple{typeof(Trixi.entropy_timederivative)}, SVector{3, Float64}, @NamedTuple{u_local::StrideArraysCore.StaticStrideArray{Float64, 2, (1, 2), Tuple{Static.StaticInt{3}, Static.StaticInt{7}}, Tuple{Nothing, Nothing}, Tuple{Static.StaticInt{1}, Static.StaticInt{1}}, 21}, x_local::StrideArraysCore.StaticStrideArray{Float64, 2, (1, 2), Tuple{Static.StaticInt{1}, Static.StaticInt{7}}, Tuple{Nothing, Nothing}, Tuple{Static.StaticInt{1}, Static.StaticInt{1}}, 7}}}, typeof(Trixi.initialize!), typeof(SciMLBase.FINALIZE_DEFAULT)}(Trixi.var&quot;#1429#1436&quot;{Int64}(100), AnalysisCallback{Trixi.LobattoLegendreAnalyzer{Float64, 7, SVector{7, Float64}, Matrix{Float64}}, Tuple{typeof(Trixi.entropy_timederivative)}, SVector{3, Float64}, @NamedTuple{u_local::StrideArraysCore.StaticStrideArray{Float64, 2, (1, 2), Tuple{Static.StaticInt{3}, Static.StaticInt{7}}, Tuple{Nothing, Nothing}, Tuple{Static.StaticInt{1}, Static.StaticInt{1}}, 21}, x_local::StrideArraysCore.StaticStrideArray{Float64, 2, (1, 2), Tuple{Static.StaticInt{1}, Static.StaticInt{7}}, Tuple{Nothing, Nothing}, Tuple{Static.StaticInt{1}, Static.StaticInt{1}}, 7}}}(0.0, 0.0, 0, 0.0, 100, false, &quot;out&quot;, &quot;analysis.dat&quot;, LobattoLegendreAnalyzer{Float64}(polydeg=6), [:l2_error, :linf_error], (Trixi.entropy_timederivative,), [0.0, 0.0, 0.0], (u_local = [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], x_local = [0.0 0.0 … 0.0 0.0])), Trixi.initialize!, SciMLBase.FINALIZE_DEFAULT, Bool[0, 0]), AliveCallback(alive_interval=10), StepsizeCallback(cfl_number=0.5)))</code></pre><p>We specify the <code>stage_limiter!</code> supplied to the classic SSPRK33 integrator with strict entropy increase enforcement (recall that the tolerated exponentiated entropy decrease is set to -1e-13).</p><pre><code class="language-julia hljs">stage_limiter! = EntropyBoundedLimiter()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EntropyBoundedLimiter{Float32}(-1.0f-13)</code></pre><p>We run the simulation with the SSPRK33 method and the entropy bounded limiter:</p><pre><code class="language-julia hljs">sol = solve(ode, SSPRK33(stage_limiter!);
            dt = 1.0,
            callback = callbacks);

using Plots
plot(sol)</code></pre><img src="88a69251.svg" alt="Example block output"/><h2 id="Package-versions"><a class="docs-heading-anchor" href="#Package-versions">Package versions</a><a id="Package-versions-1"></a><a class="docs-heading-anchor-permalink" href="#Package-versions" title="Permalink"></a></h2><p>These results were obtained using the following versions.</p><pre><code class="language-julia hljs">using InteractiveUtils
versioninfo()

using Pkg
Pkg.status([&quot;Trixi&quot;, &quot;OrdinaryDiffEq&quot;, &quot;Plots&quot;],
           mode = PKGMODE_MANIFEST)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Julia Version 1.10.7
Commit 4976d05258e (2024-11-26 15:57 UTC)
Build Info:
  Official https://julialang.org/ release
Platform Info:
  OS: Linux (x86_64-linux-gnu)
  CPU: 4 × AMD EPYC 7763 64-Core Processor
  WORD_SIZE: 64
  LIBM: libopenlibm
  LLVM: libLLVM-15.0.7 (ORCJIT, znver3)
Threads: 1 default, 0 interactive, 1 GC (on 4 virtual cores)
Environment:
  JULIA_PKG_SERVER_REGISTRY_PREFERENCE = eager
<span class="sgr32"><span class="sgr1">Status</span></span> `~/work/Trixi.jl/Trixi.jl/docs/Manifest.toml`
<span class="sgr32">⌃</span> <span class="sgr90">[1dea7af3] </span>OrdinaryDiffEq v6.66.0
  <span class="sgr90">[91a5bcdd] </span>Plots v1.40.9
  <span class="sgr90">[a7f1ee26] </span>Trixi v0.9.12 `~/work/Trixi.jl/Trixi.jl`
<span class="sgr36"><span class="sgr1">Info</span></span> Packages marked with <span class="sgr32">⌃</span> have new versions available and may be upgradable.</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../DGSEM_FluxDiff/">« 4 DGSEM with flux differencing</a><a class="docs-footer-nextpage" href="../subcell_shock_capturing/">6 Subcell limiting with the IDP Limiter »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 20 December 2024 05:31">Friday 20 December 2024</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
